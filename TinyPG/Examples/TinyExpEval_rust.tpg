//@TinyPG - a Tiny Parser Generator v1.6
//Copyright Â© Herre Kuijpers 2008-2010, modified by ultrasuperpingu 2023
// https://www.codeproject.com/Articles/241830/a-Tiny-Expression-Evaluator

<% @TinyPG Language="rust" OutputPath="TestRust\TinyExe\src" Namespace="TinyExe" %>

<% @ParseTree CustomCode={
	// helper function to find access the function or variable
	pub fn GetFunctionOrVariable(n:&Box<dyn IParseNode>) -> Option<&Box<dyn IParseNode>>
	{
		// found the right node, exit
		if n.get_token()._type == TokenType::Function || n.get_token()._type == TokenType::VARIABLE {
			return Some(n);
		}

		if n.get_nodes().len() == 1 { // search lower branch (left side only, may not contain other node branches)
			return Self::GetFunctionOrVariable(&n.get_nodes()[0]);
		}
		// function or variable not found in branch
		return None;
	}
	//Context* context = NULL;}; HeaderCode=@"
" %>

[Color(0, 0, 255)]
BOOLEANLITERAL	-> @"true|false";
[Color(255, 0, 0)]
DECIMALINTEGERLITERAL-> @"[0-9]+(UL|Ul|uL|ul|LU|Lu|lU|lu|U|u|L|l)?";
[Color(255, 0, 0)]
REALLITERAL 		-> @"([0-9]+\.[0-9]+([eE][+-]?[0-9]+)?([fFdDMm]?)?)|(\.[0-9]+([eE][+-]?[0-9]+)?([fFdDMm]?)?)|([0-9]+([eE][+-]?[0-9]+)([fFdDMm]?)?)|([0-9]+([fFdDMm]?))";
HEXINTEGERLITERAL	-> @"0(x|X)[0-9a-fA-F]+";
[Color(155, 0, 0)]
STRINGLITERAL		-> @"\""(\""\""|[^\""])*\"""; // shortcut implementation, not quite ready
[Color(0, 80, 0)]
FUNCTION		-> @"[a-zA-Z_][a-zA-Z0-9_]*(?=\s*\()"; // matches only when followed by (
VARIABLE		-> @"[a-zA-Z_][a-zA-Z0-9_]*(?!\s*\()"; // matches only when NOT followed by (
CONSTANT		-> @"pi|e";

BRACEOPEN		-> @"\{\s*";
BRACECLOSE		-> @"\s*\}";
BRACKETOPEN		-> @"\(\s*";
BRACKETCLOSE		-> @"\s*\)";
SEMICOLON		-> @";";
PLUSPLUS		-> @"\+\+";
MINUSMINUS		-> @"--";
PIPEPIPE		-> @"\|\||or";
AMPAMP			-> @"&&|and";
AMP			-> @"&(?!&)"; // matches only when NOT followed by second &
POWER			-> @"\^";
PLUS			-> @"\+";
MINUS			-> @"-";
EQUAL			-> @"=";
ASSIGN			-> @":=";
NOTEQUAL		-> @"!=|<>";
NOT			-> @"!";
ASTERIKS		-> @"\*";
SLASH			-> @"/";
PERCENT		-> @"%";
QUESTIONMARK		-> @"\?";
COMMA			-> @",";
LESSEQUAL		-> @"<=";
GREATEREQUAL		-> @">=";
LESSTHAN		-> @"<(?!>)"; // matches only when not followed by >
GREATERTHAN		-> @">";
COLON			-> @":";
EOF_			-> @"$";


[Skip] WHITESPACE 	-> @"\s+";


Start -> (Expression)? EOF_
{
	return $Expression;
};

//expressions
Function -> FUNCTION BRACKETOPEN Params? BRACKETCLOSE
{
	/*let tree = &mut paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	ParseNode* funcNode = this->Nodes[0];
	ParseNode* paramNode = this->Nodes[2];

	if (tree->context == NULL)
	{
		tree.errors.push(ParseError::from_parse_node("No context defined", 1041, self));
		return NULL;
	}
	if (tree->context->CurrentStackSize > 50)
	{
		tree.errors.push(ParseError::from_parse_node("Stack overflow: " + funcNode->TokenVal.Text + "()", 1046, self));
		return NULL;
	}
	std::string key = str_tolower(funcNode->TokenVal.Text);
	if (!containsKey(tree->context->functions, key))
	{
		tree->Errors.push_back(ParseError("Fuction not defined: " + funcNode->TokenVal.Text + "()", 1042, this));
		return NULL;
	}

	// retrieves the function from declared functions
	class Function* func = tree->context->functions[key];

	// evaluate the function parameters
	std::vector<std::any> parameters = std::vector<std::any>();
	if (paramNode->TokenVal.Type == TokenType::Params)
		parameters = std::any_cast<std::vector<std::any>>(paramNode->Eval(paramlist));
	if (parameters.size() < func->MinParameters) 
	{
		tree->Errors.push_back(ParseError("At least " + std::to_string(func->MinParameters) + " parameter(s) expected", 1043, this));
		return NULL; // illegal number of parameters
	}
	else if (parameters.size() > func->MaxParameters)
	{
		tree->Errors.push_back(ParseError("No more than " + std::to_string(func->MaxParameters) + " parameter(s) expected", 1044, this));
		return NULL; // illegal number of parameters
	}
	
	return func->Eval(parameters, tree);*/
	None
};
PrimaryExpression -> Function | Variable | Literal | ParenthesizedExpression
{
	let _type = self.nodes[0].get_token()._type;
	if _type == TokenType::Function {
		return self.get_function_value(0, paramlist);
	} else if _type == TokenType::Literal {
		return self.get_literal_value(0, paramlist);
	} else if _type == TokenType::ParenthesizedExpression {
		return self.get_parenthesizedexpression_value(0, paramlist);
	} else if _type == TokenType::Variable {
		return self.get_variable_value(0, paramlist);
	}
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	tree.errors.push(ParseError::from_parse_node("Illegal EvalPrimaryExpression format".to_string(), 1097, self, false));
	None
};
ParenthesizedExpression -> BRACKETOPEN Expression BRACKETCLOSE
{
	$Expression
};
UnaryExpression -> PrimaryExpression
				   | PLUS UnaryExpression
				   | MINUS UnaryExpression
				   | NOT UnaryExpression
{
	let _type = self.nodes[0].get_token()._type;
		if _type == TokenType::PrimaryExpression {
			return self.get_primaryexpression_value(0, paramlist);
		}
		if _type == TokenType::MINUS
		{
			let val_opt = self.get_unaryexpression_value(0, paramlist);
			if let Some(val) = val_opt {
				match val.downcast::<f64>() {
					Ok(dval) => {
						return Some(Box::new(-*dval));
					},
					Err(val) => {
						match val.downcast::<i64>() {
							Ok(ival) => {
								return Some(Box::new(-*ival));
							},
							Err(_) => {
								
							}
						}
					}
				}
			}
			let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
			tree.errors.push(ParseError::from_parse_node("Illegal UnaryExpression format, cannot interpret minus ".to_string() /*+ val*/, 1095, self, false));
			return None;
		}
		else if _type == TokenType::PLUS
		{
			let val = self.get_unaryexpression_value(0, paramlist);
			return val;
		}
		else if _type == TokenType::NOT
		{
			let val = self.get_unaryexpression_value(0, paramlist);
			let bval_res = val.unwrap().downcast::<bool>();
			if let Ok(bval) = bval_res {
				return Some(Box::new(!(*bval)));
			}
			let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
			tree.errors.push(ParseError::from_parse_node("Illegal UnaryExpression format, cannot interpret negate ".to_string() /*+ val*/, 1098, self, false));
			return None;
		}
	
		let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
		tree.errors.push(ParseError::from_parse_node("Illegal UnaryExpression format".to_string(), 1099, self, false));
		None
};

PowerExpression -> UnaryExpression (POWER UnaryExpression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_unaryexpression_value(0, paramlist);
	//TODO: uncomment and make it work
/*
	// IMPORTANT: scanning and calculating the power is done from Left to Right.
	// this is conform the Excel evaluation of power, but not conform strict mathematical guidelines
	// this means that a^b^c evaluates to (a^b)^c  (Excel uses the same kind of evaluation)
	// stricly mathematical speaking a^b^c should evaluate to a^(b^c) (therefore calculating the powers from Right to Left)
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if token._type == TokenType::POWER {
			result = std::pow(ConvertToDouble(result), ConvertToDouble(val));
		}
	}*/
	
	result
};
MultiplicativeExpression -> PowerExpression ((ASTERIKS | SLASH | PERCENT) PowerExpression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_powerexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if token._type == TokenType::ASTERIKS {
			result = ConvertToDouble(result) * ConvertToDouble(val);
		} else if token._type == TokenType::SLASH {
			result = ConvertToDouble(result) / ConvertToDouble(val);
		} else if token._type == TokenType::PERCENT {
			result = ConvertToInt32(result) % ConvertToInt32(val);
		}
	}
	*/
	result
};
AdditiveExpression -> MultiplicativeExpression ((PLUS | MINUS) MultiplicativeExpression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_multiplicativeexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if token._type == TokenType::PLUS {
			result = ConvertToDouble(result) + ConvertToDouble(val);
		} else if token._type == TokenType::MINUS {
			result = ConvertToDouble(result) - ConvertToDouble(val);
		}
	}
	*/
	result
}; 
ConcatEpression -> AdditiveExpression (AMP AdditiveExpression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_additiveexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if token._type == TokenType::AMP {
			result = ConvertToString(result) + ConvertToString(val);
		}
	}
	*/
	result
};
RelationalExpression -> ConcatEpression ((LESSTHAN | LESSEQUAL | GREATERTHAN | GREATEREQUAL) ConcatEpression)?
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_concatepression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
	
		// compare as numbers
		if (result.has_value() && result.type().name() == "double" && val.has_value() && val.type().name() == "double")
		{
			if token._type == TokenType::LESSTHAN {
				result = ConvertToDouble(result) < ConvertToDouble(val);
			} else if token._type == TokenType::LESSEQUAL {
				result = ConvertToDouble(result) <= ConvertToDouble(val);
			} else if token._type == TokenType::GREATERTHAN {
				result = ConvertToDouble(result) > ConvertToDouble(val);
			} else if token._type == TokenType::GREATEREQUAL {
				result = ConvertToDouble(result) >= ConvertToDouble(val);
			}
		}
		else // compare as strings
		{
			if token._type == TokenType::LESSTHAN {
				result = ConvertToString(result) < ConvertToString(val);
			} else if token._type == TokenType::LESSEQUAL {
				result = ConvertToString(result) <= ConvertToString(val);
			} else if token._type == TokenType::GREATERTHAN {
				result = ConvertToString(result) > ConvertToString(val);
			} else if token._type == TokenType::GREATEREQUAL {
				result = ConvertToString(result) >= ConvertToString(val);
			}
		}
	}
	*/
	result
};
EqualityExpression -> RelationalExpression ((EQUAL | NOTEQUAL) RelationalExpression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_relationalexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if result.is_some() && !val.has_value() || result.is_none() && val.has_value()
		{
			if token._type == TokenType::EQUAL {
				result = Some(Box::new(false));
			} else if token._type == TokenType::NOTEQUAL {
				result = Some(Box::new(true));
			}
		}
		else if result.is_none() && !val.has_value()
		{
			if token._type == TokenType::EQUAL {
				result = Some(Box::new(true));
			} else if token._type == TokenType::NOTEQUAL {
				result = Some(Box::new(false));
			}
		}
		else // if (result.has_value() && val.has_value())
		{
			if result.type().name() != val.type().name()
			{
				if token._type == TokenType::EQUAL {
					result = Some(Box::new(true));
				} else if token._type == TokenType::NOTEQUAL {
					result = Some(Box::new(false));
				}
			}
			else
			{
				if (auto x = std::any_cast<bool>(&val))
				{
					if token._type == TokenType::EQUAL {
						result = std::any_cast<bool>(result) == std::any_cast<bool>(val);
					} else if token._type == TokenType::NOTEQUAL {
						result = std::any_cast<bool>(result) != std::any_cast<bool>(val);
					}
				}
				else if (auto x = std::any_cast<double>(&val))
				{
					if token._type == TokenType::EQUAL {
						result = std::any_cast<double>(result) == std::any_cast<double>(val);
					} else if token._type == TokenType::NOTEQUAL {
						result = std::any_cast<double>(result) != std::any_cast<double>(val);
					}
				}
				else if (auto x = std::any_cast<int>(&val))
				{
					if token._type == TokenType::EQUAL {
						result = std::any_cast<int>(result) == std::any_cast<int>(val);
					} else if token._type == TokenType::NOTEQUAL {
						result = std::any_cast<int>(result) != std::any_cast<int>(val);
					}
				}
				else if (auto x = std::any_cast<std::string>(&val))
				{
					if token._type == TokenType::EQUAL {
						result = std::any_cast<std::string>(result) == std::any_cast<std::string>(val);
					} else if token._type == TokenType::NOTEQUAL {
						result = std::any_cast<std::string>(result) != std::any_cast<std::string>(val);
					}
				}
			}
		}
	}
	*/
	result
};
ConditionalAndExpression -> EqualityExpression (AMPAMP EqualityExpression)*  //ok
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_equalityexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if (token._type == TokenType::AMPAMP) {
			result = ConvertToBoolean(result) && ConvertToBoolean(val);
		}
	}
	*/
	result
};
ConditionalOrExpression -> ConditionalAndExpression (PIPEPIPE ConditionalAndExpression)* //ok
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_equalityexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	for i in (1..self.nodes.len()).step_by(2)
	{
		let token = self.nodes[i].get_token();
		let val = self.nodes[i + 1].eval(paramlist);
		if (token._type == TokenType::PIPEPIPE) {
			result = ConvertToBoolean(result) || ConvertToBoolean(val);
		}
	}
	*/
	result
};
AssignmentExpression -> ConditionalOrExpression (QUESTIONMARK AssignmentExpression COLON AssignmentExpression)? // ok
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let result = self.get_conditionalorexpression_value(0, paramlist);
	//TODO: uncomment and make it work
	/*
	if (self.nodes.len() >= 5 && result.is_some() && std::any_cast<int>(&result)
		&& self.nodes[1].get_token()._type == TokenType::QUESTIONMARK
		&& self.nodes[3].get_token()._type == TokenType::COLON)
	{
		if ConvertToBoolean(result) {
			result = self.nodes[2]->eval(paramlist); // return 1st argument
		} else {
			result = self.nodes[4]->eval(paramlist); // return 2nd argument
		}
	}
	*/
	result
};
Expression -> AssignmentExpression? (ASSIGN AssignmentExpression)?
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	// if only left hand side available, this is not an assignment, simple evaluate expression
	if self.nodes.len() == 1 {
		return self.get_assignmentexpression_value(0, paramlist); // return the result
	}
	if self.nodes.len() != 3
	{
		let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
		tree.errors.push(ParseError::from_parse_node("Illegal EvalExpression format".to_string(), 1092, self, false));
		return None;
	}
	
	// ok, this is an assignment so declare the function or variable
	// assignment only allowed to function or to a variable
	/*let v = Self::GetFunctionOrVariable(&self.nodes[0]);
	if v.is_none()
	{
		let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
		tree.errors.push(ParseError::from_parse_node("Can only assign to function or variable".to_string(), 1020, self, false));
		return None;
	}
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	if tree.context.is_none()
	{
		tree.errors.push(ParseError::from_parse_node("No context defined".to_string(), 1041, self, false));
		return None;
	}
	
	let vtoken = v.as_ref().unwrap().get_token();
	if vtoken._type == TokenType::VARIABLE
	{
		// simply overwrite any previous defnition
		let key = &vtoken.text;
		tree.context.Globals[key] = self.get_assignmentexpression_value(1, paramlist);
		return tree.context.Globals[key] ;
	}
	else if vtoken._type == TokenType::Function
	{
	
		let key = &v.as_ref().unwrap().get_nodes()[0].get_token().text;
	
		// function lookup is case insensitive
		if (containsKey(tree->context->functions, key.to_lowercase()))
		{
			let func = tree->context->functions[key.to_lowercase()];
			if (!func->IsDynamic())
			{
				tree.errors.push(ParseError::from_parse_node("Built in functions cannot be overwritten".to_string(), 1050, self, false));
				return None;
			}
		}
		// lets determine the input variables. 
		// functions must be of te form f(x;y;z) = x+y*z;
		// check the function parameters to be of type Variable, error otherwise
		let vars = Variables::new();
		let paramsNode = v.get_nodes()[2];
		if (paramsNode->TokenVal.Type == TokenType::Params)
		{   // function has parameters, so check if they are all variable declarations
			for i in (0..paramsNode.nodes.len()).step_by(2)
			{
				let varNode = Self::GetFunctionOrVariable(paramsNode.nodes[i]);
				if varNode.is_none() || varNode.unwrap().get_token()._type != TokenType::VARIABLE
				{
					tree.errors.push(ParseError::from_parse_node("Function declaration may only contain variables".to_string(), 1051, self, false));
					return None;
				}
				// simply declare the variable, no need to evaluate the value of it at this point. 
				// evaluation will be done when the function is executed
				// note, variables are Case Sensitive (!)
				vars.insert(varNode.unwrap().get_token().text, None);
			}
		}
		// we have all the info we need to know to declare the dynamicly defined function
		// pass on nodes[2] which is the Right Hand Side (RHS) of the assignment
		// nodes[2] will be evaluated at runtime when the function is executed.
		let dynf = DynamicFunction::new (key, self.nodes[2], vars, vars.len(), vars.len());
		tree.context.functions[key.to_lowercase()] = dynf;
		return dynf;
	}*/

	None
};

//literals
Params -> Expression (SEMICOLON Expression)*
{
	//let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	let parameters : Vec<Box<dyn std::any::Any>> = vec![];
	//TODO
	/*for i in (0..self.nodes.len()).step_by(2)
	{
		if (self.nodes[i].get_token()._type == TokenType::Expression)
		{
			let val = self.nodes[i]->eval(paramlist);
			parameters.push(val);
		}
	}*/
	Some(Box::new(parameters))
};
Literal -> BOOLEANLITERAL | IntegerLiteral | RealLiteral | StringLiteral
{
	let _type = self.nodes[0].get_token()._type;
	if (_type == TokenType::StringLiteral) {
		return self.get_stringliteral_value(0, paramlist);
	} else if (_type == TokenType::IntegerLiteral) {
		return self.get_integerliteral_value(0, paramlist);
	} else if (_type == TokenType::RealLiteral) {
		return self.get_realliteral_value(0, paramlist);
	} else if (_type == TokenType::BOOLEANLITERAL) {
		return Some(Box::new(self.get_terminal_value(TokenType::BOOLEANLITERAL, 0) == "true"));
	}
	
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	tree.errors.push(ParseError::from_parse_node("illegal Literal format".to_string(), 1003, self, false));
	None
};
IntegerLiteral -> DECIMALINTEGERLITERAL | HEXINTEGERLITERAL
{
	if self.is_token_present(TokenType::DECIMALINTEGERLITERAL, 0) {
		return Some(Box::new(self.get_terminal_value(TokenType::DECIMALINTEGERLITERAL, 0).parse::<i64>()));
	}
	if self.is_token_present(TokenType::HEXINTEGERLITERAL, 0)
	{
		let hex = self.get_terminal_value(TokenType::HEXINTEGERLITERAL, 0);
		return Some(Box::new(i64::from_str_radix(&hex[2..], 16)));
	}
	
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	tree.errors.push(ParseError::from_parse_node("illegal IntegerLiteral format".to_string(), 1002, self, false));
	None
};
RealLiteral -> REALLITERAL
{
	if (self.is_token_present(TokenType::REALLITERAL, 0))
	{
		return Some(Box::new(self.get_terminal_value(TokenType::REALLITERAL, 0).parse::<f64>().unwrap()));
	}
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	tree.errors.push(ParseError::from_parse_node("illegal RealLiteral format".to_string(), 1001, self, false));
		
	None
};
StringLiteral -> STRINGLITERAL
{
	if self.is_token_present(TokenType::STRINGLITERAL, 0)
	{
		let mut r = self.get_terminal_value(TokenType::STRINGLITERAL, 0);
		r = r.trim_matches('"').to_string(); // strip quotes
		return Some(Box::new(r));
	}
	
	let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	tree.errors.push(ParseError::from_parse_node("illegal StringLiteral format".to_string(), 1000, self, false));
	Some(Box::new("".to_string()))
};
Variable -> VARIABLE
{
	/*let tree = paramlist.first_mut().unwrap().downcast_mut::<ParseTree>().unwrap();
	if tree.context.is_none()
	{
		tree.errors.push(ParseError::from_parse_node("No context defined".to_string(), 1041, self, false));
		return None;
	}
	
	let key = self.get_terminal_value(TokenType::VARIABLE, 0);
	// first check if the variable was declared in scope of a function
	let scope_var = tree.context.unwarp().GetScopeVariable(key);
	if scope_var.is_some() {
		return scope_var.unwarp();
	}
		
	// if not in scope of a function
	// next check if the variable was declared as a global variable
	if containsKey(tree->context->Globals,key) {
		return tree->context->Globals[key];
	}
	
	//variable not found
	tree.errors.push(ParseError::from_parse_node("Variable not defined: ".to_string() + &key, 1039, self, false));
	None*/
	//just for testing
	Some(Box::new(2))
};
